let's take a loot at the C code...


```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

int main()
{
	int i;
	time_t var0 = time(NULL);
	srand(var0);
	
	int var1 = 0;
	char buf0[500];
	char buf1[500];
	
	for (i=0; i<50; i++) {
		int var2 = rand() % 100;
		printf("%d days without an incident.\n", i);
		sprintf(buf1, "%d", var2);
		scanf(" %10s", buf0);
		strtok(buf0, "\n");
		if (strcmp(buf1, buf0) != 0) {
			printf("Well that didn't take long.\n");
			printf("You should have used %s.\n", buf1);
			exit(0);
		}
	}
	
	printf("How very unpredictable. Level Cleared\n");
	}
}

```

So what we see here is a random number generator. This particular random number generator used the C rand() function for it's randomization. The thing about the C rand() function, is that it requires a seed, or a value to be passed to it. The thing about the seed is since the random number sequence is based off of the seed, if you have the same seed then you will generate the same sequence or supposedly random numbers. We cab see what it uses as a seed. Keep in mind that the random number it generated undergoes the modular operator (%) which essentially divides it by an integer and returns the remainder. In this case it divides it by 100 and reutrns the remainder, so the number that is stored in var2 cannot be bigger than 99.

```
	int i;
	time_t var0 = time(NULL);
	srand(var0);
```

As you can see there, it uses the system time as a seed. So if we just get the same system time as the machine it is running as, we can generate the same sequence of random (not really random) numbers, while keeping in mind of the "% 100". For this we can write a simple C progrma...

```
$	cat exploit.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
	int i;
	time_t t;
	t = time(NULL);
	srand(t);
	for (i=0; i<50; i++) 
	{
		int r = rand() % 100;
		printf("%d\n", r);
	}
}


```

As you can see there, this is just a program that will output the first 50 numbers that are generated by the C rand() function when using system time as a seed. Let's test it...

```
$	./exploit
51
96
73
11
36
19
4
93
0
46
95
25
55
53
90
15
48
42
33
69
86
74
91
71
8
6
21
68
33
93
1
84
41
27
96
77
98
52
23
98
99
70
75
54
23
66
21
71
8
54
```

Now let's try to run the exploit against the challenge...

```
$	./exploit | ./e0
0 days without an incident.
1 days without an incident.
2 days without an incident.
3 days without an incident.
4 days without an incident.
5 days without an incident.
6 days without an incident.
7 days without an incident.
8 days without an incident.
9 days without an incident.
10 days without an incident.
11 days without an incident.
12 days without an incident.
13 days without an incident.
14 days without an incident.
15 days without an incident.
16 days without an incident.
17 days without an incident.
18 days without an incident.
19 days without an incident.
20 days without an incident.
21 days without an incident.
22 days without an incident.
23 days without an incident.
24 days without an incident.
25 days without an incident.
26 days without an incident.
27 days without an incident.
28 days without an incident.
29 days without an incident.
30 days without an incident.
31 days without an incident.
32 days without an incident.
33 days without an incident.
34 days without an incident.
35 days without an incident.
36 days without an incident.
37 days without an incident.
38 days without an incident.
39 days without an incident.
40 days without an incident.
41 days without an incident.
42 days without an incident.
43 days without an incident.
44 days without an incident.
45 days without an incident.
46 days without an incident.
47 days without an incident.
48 days without an incident.
49 days without an incident.
How very unpredictable. Level Cleared
```

Just like that, we pwned the binary. Now to patch the binary.

```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

int main()
{
	FILE *ran_file;
	unsigned int int0;
	int i;	
	for (i=0; i<50; i++) {
		printf("%d days without an incident.\n", i);
		ran_file = fopen("/dev/urandom", "r");
		fread(&int0, sizeof(int0), 1, ran_file);
		fclose(ran_file);
		int0 = int0 % 100;
		char buf0[10];
		fgets(buf0, sizeof(buf0), stdin);
		if (int0 != atoi(buf0))
		{
			printf("Well that didn't take long.\n");
			printf("You should have used %d.\n", int0);
			exit(0);
		}
	}
	printf("How very unpredictable. Level Cleared\n");
}
```

As you can see here, we are no longer using the rand() function. Instead we are reading from the file "/dev/urandom". This is a file in linux that is generated automatically that contains random data that is cryptographically secure. So we are able to simply read from it to get our random values. Now to test it, we will create a program that reads from that file to. Here it is.

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <linux/random.h>
#include <sys/syscall.h>
#include <unistd.h>

int main()
{
	FILE *ran_file;
	unsigned int int0;
	int i;
	for (i=0; i<50; i++)
	{
 		ran_file = fopen("/dev/urandom", "r");
        	fread(&int0, sizeof(int0), 1, ran_file);
        	fclose(ran_file);
  		int0 = int0 % 100;
		printf("%u\n", int0);
	}
}
```

Now let's try both exploits against the patched varsion.

```
$	./exploit_secure | ./e0_secure 
0 days without an incident.
Well that didn't take long.
You should have used 72.
$	./exploit | ./e0_secure 
0 days without an incident.
Well that didn't take long.
You should have used 98.
```

Just like that, we patched the binary!